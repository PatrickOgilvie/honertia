# Honertia

[![npm version](https://img.shields.io/npm/v/honertia.svg)](https://www.npmjs.com/package/honertia)
[![Bundle Size](https://img.shields.io/bundlephobia/minzip/honertia)](https://bundlephobia.com/package/honertia)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.0-blue.svg)](https://www.typescriptlang.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

[![Hono](https://img.shields.io/badge/Hono-E36002?logo=hono&logoColor=fff)](https://hono.dev/)
[![Cloudflare Workers](https://img.shields.io/badge/Cloudflare%20Workers-F38020?logo=cloudflare&logoColor=fff)](https://workers.cloudflare.com/)
[![Effect](https://img.shields.io/badge/Effect-TS-black)](https://effect.website/)

## Overview

An Inertia.js-style adapter for Hono with Effect.ts integration. Inertia keeps a server-driven app but behaves like an SPA: link clicks and form posts are intercepted, a fetch/XHR request returns a JSON page object (component + props), and the client swaps the page without a full reload. Honertia layers Laravel-style route patterns and Effect actions on top of that so handlers stay clean, readable, and composable.

## Raison d'√™tre

I wanted to build on Cloudflare Workers whilst retaining the ergonomics of the Laravel+Inertia combination. There are certain patterns that I always use with Laravel (such as the laravel-actions package) and so we have incorporated those ideas into honertia. Now, we can't have Laravel in javascript - but we can create it in the aggregate. For auth we have used better-auth, for validation we have leant on Effect's Schema, and for the database we are using Drizzle. To make it testable and hardy we wrapped everything in Effect.ts

## Installation

```bash
bun add honertia
```

### Demo

Deploy the honertia-worker-demo repo to Cloudflare

[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/PatrickOgilvie/honertia-worker-demo)

## Quick Start


### Recommended File Structure

```
.
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ index.ts                 # Hono app setup (setupHonertia)
‚îÇ   ‚îú‚îÄ‚îÄ routes.ts                # effectRoutes / effectAuthRoutes
‚îÇ   ‚îú‚îÄ‚îÄ main.tsx                 # Inertia + React client entry
‚îÇ   ‚îú‚îÄ‚îÄ styles.css               # Tailwind CSS entry
‚îÇ   ‚îú‚îÄ‚îÄ actions/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ projects/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ list.ts           # listProjects action
‚îÇ   ‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Projects/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Index.tsx         # render('Projects/Index')
‚îÇ   ‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ db.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ schema.ts
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.ts
‚îÇ   ‚îî‚îÄ‚îÄ types.ts
‚îú‚îÄ‚îÄ dist/
‚îÇ   ‚îî‚îÄ‚îÄ manifest.json            # generated by Vite build
‚îú‚îÄ‚îÄ vite.config.ts
‚îú‚îÄ‚îÄ wrangler.toml                # or wrangler.jsonc
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ tsconfig.json
```

```typescript
// src/index.ts
import { Hono } from 'hono'
import { logger } from 'hono/logger'
import { setupHonertia, createTemplate, createVersion, registerErrorHandlers, vite } from 'honertia'
import { Context, Layer } from 'effect'
import manifest from '../dist/manifest.json'

import type { Env } from './types'
import { createDb } from './db/db'
import { createAuth } from './lib/auth'
import { registerRoutes } from './routes'

const app = new Hono<Env>()
const assetVersion = createVersion(manifest)
const entry = manifest['src/main.tsx']
const assetPath = (path: string) => `/${path}`

class BindingsService extends Context.Tag('app/Bindings')<
  BindingsService,
  { KV: KVNamespace }
>() {}

// Request-scoped setup: put db/auth on c.var so Honertia/Effect can read them.
app.use('*', async (c, next) => {
  c.set('db', createDb(c.env.DATABASE_URL))
  c.set('auth', createAuth({
    db: c.var.db,
    secret: c.env.BETTER_AUTH_SECRET,
    baseURL: new URL(c.req.url).origin,
  }))
  await next()
})

// Honertia bundles the core middleware + auth loading + Effect runtime setup.
app.use('*', setupHonertia<Env, BindingsService>({
  honertia: {
    // Use your asset manifest hash so Inertia reloads on deploy.
    version: assetVersion,
    render: createTemplate((ctx) => {
      const isProd = ctx.env.ENVIRONMENT === 'production'
      return {
        title: 'My Web App',
        scripts: isProd ? [assetPath(entry.file)] : [vite.script()],
        styles: isProd ? (entry.css ?? []).map(assetPath) : [],
        head: isProd ? '' : vite.hmrHead(),
      }
    }),
  },
  effect: {
    // Expose Cloudflare bindings to Effect handlers via a service layer.
    services: (c) => Layer.succeed(BindingsService, {
      KV: c.env.MY_KV,
    }),
  },
  // Optional: extra Hono middleware in the same chain.
  middleware: [
    logger(),
    // register additional middleware here...
  ],
}))

registerRoutes(app)
registerErrorHandlers(app)

export default app
```

```typescript
// src/routes.ts
import type { Hono } from 'hono'
import type { Env } from './types'
import { effectRoutes } from 'honertia/effect'
import { effectAuthRoutes, RequireAuthLayer } from 'honertia/auth'
import { showDashboard, listProjects, createProject, showProject, deleteProject } from './actions'
import { loginUser, registerUser, logoutUser } from './actions/auth'

export function registerRoutes(app: Hono<Env>) {
  // Auth routes: pages, form actions, logout, and API handler in one place.
  effectAuthRoutes(app, {
    loginComponent: 'Auth/Login',
    registerComponent: 'Auth/Register',
    // Form actions (automatically wrapped with RequireGuestLayer)
    loginAction: loginUser,
    registerAction: registerUser,
    logoutAction: logoutUser,
  })

  // Effect routes give you typed, DI-friendly handlers (no direct Hono ctx).
  effectRoutes(app)
    .provide(RequireAuthLayer)
    .group((route) => {
      // Grouped routes share layers and path prefixes.
      route.get('/', showDashboard) // GET example.com

      route.prefix('/projects').group((route) => {
        route.get('/', listProjects)        // GET    example.com/projects
        route.post('/', createProject)      // POST   example.com/projects
        route.get('/:id', showProject)      // GET    example.com/projects/2
        route.delete('/:id', deleteProject) // DELETE example.com/projects/2
      })
    })
}
```

### Example Action

Here's the `listProjects` action referenced above:

```typescript
// src/actions/projects/list.ts
import { Effect } from 'effect'
import { eq } from 'drizzle-orm'
import { DatabaseService, AuthUserService, render, type AuthUser } from 'honertia/effect'
import { schema, type Database, type Project } from '../../db'

interface ProjectsIndexProps {
  projects: Project[]
}

const fetchProjects = (
  db: Database,
  user: AuthUser
): Effect.Effect<ProjectsIndexProps, Error, never> =>
  Effect.tryPromise({
    try: async () => {
      const projects = await db.query.projects.findMany({
        where: eq(schema.projects.userId, user.user.id),
        orderBy: (projects, { desc }) => [desc(projects.createdAt)],
      })
      return { projects }
    },
    catch: (error) => error instanceof Error ? error : new Error(String(error)),
  })

export const listProjects = Effect.gen(function* () {
  const db = yield* DatabaseService
  const user = yield* AuthUserService
  const props = yield* fetchProjects(db as Database, user)
  return yield* render('Projects/Index', props)
})
```

The component name `Projects/Index` maps to a file on disk. A common
Vite + React layout is:

```
src/pages/Projects/Index.tsx
```

That means the folders mirror the component path, and `Index.tsx` is the file
that exports the page component. In the example below, `Link` comes from
`@inertiajs/react` because it performs Inertia client-side visits (preserving
page state and avoiding full reloads), whereas a plain `<a>` would do a full
navigation.

```tsx
// src/pages/Projects/Index.tsx
/**
 * Projects Index Page
 */

import { Link } from '@inertiajs/react'
import Layout from '~/components/Layout'
import type { PageProps, Project } from '~/types'

interface Props {
  projects: Project[]
}

export default function ProjectsIndex({ projects }: PageProps<Props>) {
  return (
    <Layout>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold text-gray-900">Projects</h1>
        <Link
          href="/projects/create"
          className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700"
        >
          New Project
        </Link>
      </div>
      
      <div className="bg-white rounded-lg shadow">
        {projects.length === 0 ? (
          <div className="p-6 text-center text-gray-500">
            No projects yet.{' '}
            <Link href="/projects/create" className="text-indigo-600 hover:underline">
              Create your first project
            </Link>
          </div>
        ) : (
          <ul className="divide-y divide-gray-200">
            {projects.map((project) => (
              <li key={project.id}>
                <Link
                  href={`/projects/${project.id}`}
                  className="block px-6 py-4 hover:bg-gray-50"
                >
                  <div className="flex justify-between items-start">
                    <div>
                      <h3 className="text-sm font-medium text-gray-900">
                        {project.name}
                      </h3>
                      {project.description && (
                        <p className="text-sm text-gray-500 mt-1">
                          {project.description}
                        </p>
                      )}
                    </div>
                    <span className="text-sm text-gray-400">
                      {new Date(project.createdAt).toLocaleDateString()}
                    </span>
                  </div>
                </Link>
              </li>
            ))}
          </ul>
        )}
      </div>
    </Layout>
  )
}
```

### Environment Variables

Honertia reads these from `c.env` (Cloudflare Workers bindings):

```toml
# wrangler.toml
ENVIRONMENT = "production"
```

If you prefer `wrangler.jsonc`, the same binding looks like:

```jsonc
{
  "vars": {
    "ENVIRONMENT": "production"
  }
}
```

Set secrets like `DATABASE_URL` and `BETTER_AUTH_SECRET` via Wrangler (not in source control):

```bash
wrangler secret put DATABASE_URL
wrangler secret put BETTER_AUTH_SECRET
```

### Client Setup (React + Inertia)

Honertia uses the standard Inertia React client. You'll need a client entry
point and a Vite build that emits a manifest (for `createVersion`).

Install client dependencies:

```bash
bun add react react-dom @inertiajs/react
bun add -d @vitejs/plugin-react tailwindcss @tailwindcss/vite
```

Create a Vite config that enables Tailwind v4, sets up an alias used in the
examples, and emits `dist/manifest.json`:

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import path from 'path'

export default defineConfig({
  plugins: [tailwindcss(), react()],
  build: {
    outDir: 'dist',
    // Use an explicit filename so imports match build output.
    manifest: 'manifest.json',
    emptyOutDir: true,
  },
  resolve: {
    alias: {
      '~': path.resolve(__dirname, 'src'),
    },
  },
})
```

Create a Tailwind CSS entry file:

```css
/* src/styles.css */
@import "tailwindcss";

@layer base {
  body {
    margin: 0;
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", sans-serif;
    background-color: #f8fafc;
    color: #0f172a;
  }
}
```

Set up the Inertia client entry point (default path matches `vite.script()`):

```tsx
// src/main.tsx
import './styles.css'

import { createInertiaApp } from '@inertiajs/react'
import { createRoot } from 'react-dom/client'

const pages = import.meta.glob('./pages/**/*.tsx')

createInertiaApp({
  resolve: (name) => {
    const page = pages[`./pages/${name}.tsx`]
    if (!page) {
      throw new Error(`Page not found: ${name}`)
    }
    return page()
  },
  setup({ el, App, props }) {
    createRoot(el).render(<App {...props} />)
  },
})
```

The `resolve` function maps `render('Projects/Index')` to
`src/pages/Projects/Index.tsx`.

Optional: add a `tailwind.config.ts` only if you need theme extensions or
custom content globs.

### Build & Deploy Notes

The server imports `dist/manifest.json`, so it must exist at build time. In
production, read scripts and styles from the manifest (Tailwind's CSS is listed
under your entry's `css` array). When deploying with Wrangler, build the client
assets first:

```bash
# build client assets before deploying the worker
bun run build:client
wrangler deploy
```

Optional dev convenience: if you want to run the worker without building the
client, you can keep a stub `dist/manifest.json` (ignored by git) and replace it
once you run `vite build`.

### Vite Helpers

The `vite` helper provides dev/prod asset management:

```typescript
import { vite } from 'honertia'

vite.script()   // 'http://localhost:5173/src/main.tsx'
vite.hmrHead()  // HMR preamble script tags for React Fast Refresh
```

## Requirements

- **Runtime**: Node.js 18+ or Bun 1.0+
- **Peer Dependencies**:
  - `hono` >= 4.0.0
  - `better-auth` >= 1.0.0
- **Dependencies**:
  - `effect` >= 3.12.0

## Anatomy of an Action

Actions in Honertia are fully composable Effect computations. Instead of using different action factories for different combinations of features, you opt-in to exactly what you need by yielding services and helpers inside your action.

This design is inspired by Laravel's [laravel-actions](https://laravelactions.com/) package, where you opt-in to capabilities by adding methods to your action class. In Honertia, you opt-in by yielding services - the order of your `yield*` statements determines the execution order.

### The `action` Wrapper

The `action` function is a semantic wrapper that marks an Effect as an action:

```typescript
import { Effect } from 'effect'
import { action } from 'honertia/effect'

export const myAction = action(
  Effect.gen(function* () {
    // Your action logic here
    return new Response('OK')
  })
)
```

It's intentionally minimal - all the power comes from what you yield inside.

### Composable Helpers

#### `authorize` - Authentication & Authorization

Opt-in to authentication and authorization checks. Returns the authenticated user, fails with `UnauthorizedError` if no user is present, and fails with `ForbiddenError` if the check returns `false`.

```typescript
import { authorize } from 'honertia/effect'

// Just require authentication (any logged-in user)
const auth = yield* authorize()

// Require a specific role
const auth = yield* authorize((a) => a.user.role === 'admin')

// Require resource ownership (see caveat below)
const auth = yield* authorize((a) => a.user.id === project.userId)
```

If the check function returns `false`, the action fails immediately with a `ForbiddenError`.

> **Query-level vs authorize() checks**
>
> Use `authorize()` for:
> - Role/permission checks before any DB work: `authorize((a) => a.user.role === 'admin')`
> - Checks that can't be expressed in SQL
>
> For resource ownership, prefer query-level filtering:
> ```typescript
> // Better: single query, no information leakage
> const auth = yield* authorize()
> const project = yield* Effect.tryPromise(() =>
>   db.query.projects.findFirst({
>     where: and(eq(projects.id, id), eq(projects.userId, auth.user.id)),
>   })
> )
> if (!project) return yield* notFound('Project')
> ```
>
> This approach is more secure (no difference between "not found" and "not yours") and more efficient (single query).

#### `validateRequest` - Schema Validation

Opt-in to request validation using Effect Schema:

```typescript
import { Schema as S } from 'effect'
import { validateRequest, requiredString } from 'honertia/effect'

const input = yield* validateRequest(
  S.Struct({ name: requiredString, description: S.optional(S.String) }),
  { errorComponent: 'Projects/Create' }
)
// input is fully typed: { name: string, description?: string }
```

On validation failure, re-renders `errorComponent` with field-level errors.

#### `DatabaseService` - Database Access

Opt-in to database access:

```typescript
import { DatabaseService } from 'honertia/effect'

const db = yield* DatabaseService
const projects = yield* Effect.tryPromise(() =>
  db.query.projects.findMany()
)
```

#### `render` / `redirect` - Responses

Return responses from your action:

```typescript
import { render, redirect } from 'honertia/effect'

// Render a page
return yield* render('Projects/Index', { projects })

// Redirect after mutation
return yield* redirect('/projects')
```

### Building an Action

Here's how these composables work together:

```typescript
import { Effect, Schema as S } from 'effect'
import {
  action,
  authorize,
  validateRequest,
  DatabaseService,
  redirect,
  requiredString,
} from 'honertia/effect'

const CreateProjectSchema = S.Struct({
  name: requiredString,
  description: S.optional(S.String),
})

export const createProject = action(
  Effect.gen(function* () {
    // 1. Authorization - fail fast if not allowed
    const auth = yield* authorize((a) => a.user.role === 'author')

    // 2. Validation - parse and validate request body
    const input = yield* validateRequest(CreateProjectSchema, {
      errorComponent: 'Projects/Create',
    })

    // 3. Database - perform the mutation
    const db = yield* DatabaseService
    yield* Effect.tryPromise(() =>
      db.insert(projects).values({
        ...input,
        userId: auth.user.id,
      })
    )

    // 4. Response - redirect on success
    return yield* redirect('/projects')
  })
)
```

### Execution Order Matters

The order you yield services determines when they execute:

```typescript
// Authorization BEFORE validation (recommended for most actions)
// Don't waste cycles validating if user can't perform the action
const auth = yield* authorize((a) => a.user.role === 'admin')
const input = yield* validateRequest(schema)

// Validation BEFORE authorization (when you need to fetch the resource first)
// Validate the ID format, fetch from DB, then check ownership against the DB record
const { id } = yield* validateRequest(Schema.Struct({ id: Schema.UUID }))
const project = yield* db.findProjectById(id)
const auth = yield* authorize((a) => a.user.id === project.ownerId)
```

### Type Safety

Effect tracks all service requirements at the type level. Your action's type signature shows exactly what it needs:

```typescript
// This action requires: RequestService, DatabaseService
export const createProject: Effect.Effect<
  Response | Redirect,
  ValidationError | UnauthorizedError | ForbiddenError | Error,
  RequestService | DatabaseService
>
```

The compiler ensures all required services are provided when the action runs.
Note: `authorize` uses an optional `AuthUserService`, so it won't appear in the required service list unless you `yield* AuthUserService` directly or provide `RequireAuthLayer` explicitly.

### Minimal Actions

Not every action needs all features. Use only what you need:

```typescript
// Public page - no auth, no validation
export const showAbout = action(
  Effect.gen(function* () {
    return yield* render('About', {})
  })
)

// Read-only authenticated page
export const showDashboard = action(
  Effect.gen(function* () {
    const auth = yield* authorize()
    const db = yield* DatabaseService
    const stats = yield* fetchStats(db, auth)
    return yield* render('Dashboard', { stats })
  })
)

// API endpoint with just validation
export const searchProjects = action(
  Effect.gen(function* () {
    const { query } = yield* validateRequest(S.Struct({ query: S.String }))
    const db = yield* DatabaseService
    const results = yield* search(db, query)
    return yield* json({ results })
  })
)
```

### Helper Utilities

#### `dbTransaction` - Database Transactions

Run multiple database operations in a transaction with automatic rollback on failure. The database instance is passed explicitly to keep the dependency visible and consistent with other service patterns:

```typescript
import { DatabaseService, dbTransaction } from 'honertia/effect'

const db = yield* DatabaseService

yield* dbTransaction(db, async (tx) => {
  await tx.insert(users).values({ name: 'Alice', email: 'alice@example.com' })
  await tx.update(accounts).set({ balance: 100 }).where(eq(accounts.userId, id))
  // If any operation fails, the entire transaction rolls back
  return { success: true }
})
```

## Core Concepts

### Effect-Based Handlers

Route handlers are Effect computations that return `Response | Redirect`. Actions are fully composable - you opt-in to features by yielding services:

```typescript
import { Effect } from 'effect'
import {
  action,
  authorize,
  validateRequest,
  DatabaseService,
  render,
  redirect,
} from 'honertia/effect'

// Simple page render with auth
export const showDashboard = action(
  Effect.gen(function* () {
    const auth = yield* authorize()
    const db = yield* DatabaseService

    const projects = yield* Effect.tryPromise(() =>
      db.query.projects.findMany({
        where: eq(schema.projects.userId, auth.user.id),
        limit: 5,
      })
    )

    return yield* render('Dashboard/Index', { projects })
  })
)

// Form submission with permissions, validation, and redirect
export const createProject = action(
  Effect.gen(function* () {
    const auth = yield* authorize((a) => a.user.role === 'admin')
    const input = yield* validateRequest(CreateProjectSchema, {
      errorComponent: 'Projects/Create',
    })
    const db = yield* DatabaseService

    yield* Effect.tryPromise(() =>
      db.insert(schema.projects).values({
        ...input,
        userId: auth.user.id,
      })
    )

    return yield* redirect('/projects')
  })
)
```

### Services

Honertia provides these services via Effect's dependency injection:

| Service | Description |
|---------|-------------|
| `DatabaseService` | Database client (from `c.var.db`) |
| `AuthService` | Auth instance (from `c.var.auth`) |
| `AuthUserService` | Authenticated user session |
| `HonertiaService` | Page renderer |
| `RequestService` | Request context (params, query, body) |
| `ResponseFactoryService` | Response builders |

#### Custom Services

You can inject Cloudflare Worker bindings (KV, D1, Queues, Analytics Engine) as services using the `services` option in `setupHonertia`, `effectBridge`, or `effectRoutes`.

Choose the option that matches your setup:

- `setupHonertia`: recommended for most apps; keeps config in one place and applies services to every Effect handler.
- `effectBridge`: use when wiring middleware manually or when you need precise middleware ordering; applies services to all Effect handlers.
- `effectRoutes`: use when you want services scoped to a route group or different services per group.

```typescript
import { Effect, Layer, Context } from 'effect'
import { setupHonertia, effectBridge, effectRoutes } from 'honertia'

// Define your custom service
export class BindingsService extends Context.Tag('app/Bindings')<
  BindingsService,
  {
    KV: KVNamespace
    ANALYTICS: AnalyticsEngineDataset
    DB: D1Database
  }
>() {}

// Option 1: setupHonertia (global services via the one-liner setup)
app.use('*', setupHonertia<Env, BindingsService>({
  honertia: {
    version: '1.0.0',
    render: (page) => JSON.stringify(page),
  },
  effect: {
    services: (c) => Layer.succeed(BindingsService, {
      KV: c.env.MY_KV,
      ANALYTICS: c.env.ANALYTICS,
      DB: c.env.DB,
    }),
  },
}))

// Option 2: effectBridge (manual middleware wiring)
app.use('*', effectBridge<Env, BindingsService>({
  database: (c) => createDb(c.env.DATABASE_URL),
  services: (c) => Layer.succeed(BindingsService, {
    KV: c.env.MY_KV,
    ANALYTICS: c.env.ANALYTICS,
    DB: c.env.DB,
  }),
}))

// Option 3: effectRoutes (scoped to a route group)
effectRoutes<Env, BindingsService>(app, {
  services: (c) => Layer.succeed(BindingsService, {
    KV: c.env.MY_KV,
    ANALYTICS: c.env.ANALYTICS,
    DB: c.env.DB,
  }),
}).group((route) => {
  route.get('/data', getDataFromKV)
})

// Use the custom service in your actions
const getDataFromKV = Effect.gen(function* () {
  const bindings = yield* BindingsService
  const value = yield* Effect.tryPromise(() =>
    bindings.KV.get('my-key')
  )
  return yield* json({ value })
})
```

You can provide multiple bindings in any option using `Layer.mergeAll` (for example, a `QueueService` tag for a queue binding):

```typescript
app.use('*', effectBridge<Env, BindingsService | QueueService>({
  services: (c) => Layer.mergeAll(
    Layer.succeed(BindingsService, {
      KV: c.env.MY_KV,
      ANALYTICS: c.env.ANALYTICS,
      DB: c.env.DB,
    }),
    Layer.succeed(QueueService, c.env.MY_QUEUE),
  ),
}))
```

### Routing

Use `effectRoutes` for Laravel-style route definitions:

```typescript
import {
  effectRoutes,
  RequireAuthLayer,
  RequireGuestLayer,
} from 'honertia'

// Protected routes (require authentication)
effectRoutes(app)
  .provide(RequireAuthLayer)
  .prefix('/dashboard')
  .group((route) => {
    route.get('/', showDashboard)
    route.get('/settings', showSettings)
    route.post('/settings', updateSettings)
  })

// Guest-only routes
effectRoutes(app)
  .provide(RequireGuestLayer)
  .group((route) => {
    route.get('/login', showLogin)
    route.get('/register', showRegister)
  })

// Public routes (no layer)
effectRoutes(app).group((route) => {
  route.get('/about', showAbout)
  route.get('/pricing', showPricing)
})
```

## Validation

Honertia uses Effect Schema with Laravel-inspired validators:

```typescript
import { Effect, Schema as S } from 'effect'
import {
  validateRequest,
  requiredString,
  nullableString,
  email,
  password,
  redirect,
} from 'honertia'

// Define schema
const CreateProjectSchema = S.Struct({
  name: requiredString.pipe(
    S.minLength(3, { message: () => 'Name must be at least 3 characters' }),
    S.maxLength(100)
  ),
  description: nullableString,
})

// Use in handler
export const createProject = Effect.gen(function* () {
  const input = yield* validateRequest(CreateProjectSchema, {
    errorComponent: 'Projects/Create', // Re-render with errors on validation failure
  })

  // input is fully typed: { name: string, description: string | null }
  yield* insertProject(input)

  return yield* redirect('/projects')
})
```

### Validation Options

`validateRequest` accepts an options object with:

```typescript
const input = yield* validateRequest(schema, {
  // Re-render this component with errors on validation failure
  // If not set, redirects back to the previous page
  errorComponent: 'Projects/Create',

  // Override default error messages per field
  messages: {
    name: 'Please enter a project name',
    email: 'That email address is not valid',
  },

  // Human-readable field names for the :attribute placeholder
  // Use with messages like 'The :attribute field is required'
  attributes: {
    name: 'project name',
    email: 'email address',
  },
})
```

**Example with `:attribute` placeholder:**

```typescript
const schema = S.Struct({
  email: S.String.pipe(S.minLength(1, { message: () => 'The :attribute field is required' })),
})

const input = yield* validateRequest(schema, {
  attributes: { email: 'email address' },
  errorComponent: 'Auth/Register',
})
// Error: "The email address field is required"
```

### Available Validators

#### Strings
```typescript
import {
  requiredString,    // Trimmed, non-empty string
  nullableString,    // Converts empty to null
  required,          // Custom message: required('Name is required')
  alpha,             // Letters only
  alphaDash,         // Letters, numbers, dashes, underscores
  alphaNum,          // Letters and numbers only
  email,             // Validated email
  url,               // Validated URL
  uuid,              // UUID format
  min,               // min(5) - at least 5 chars
  max,               // max(100) - at most 100 chars
  size,              // size(10) - exactly 10 chars
} from 'honertia'
```

#### Numbers
```typescript
import {
  coercedNumber,     // Coerce string to number
  positiveInt,       // Positive integer
  nonNegativeInt,    // 0 or greater
  between,           // between(1, 100)
  gt, gte, lt, lte,  // Comparisons
} from 'honertia'
```

#### Booleans & Dates
```typescript
import {
  coercedBoolean,    // Coerce "true", "1", etc.
  checkbox,          // HTML checkbox (defaults to false)
  accepted,          // Must be truthy
  coercedDate,       // Coerce to Date
  nullableDate,      // Empty string -> null
  after,             // after(new Date())
  before,            // before('2025-01-01')
} from 'honertia'
```

#### Password
```typescript
import { password } from 'honertia'

const PasswordSchema = password({
  min: 8,
  letters: true,
  mixedCase: true,
  numbers: true,
  symbols: true,
})
```

## Response Helpers

```typescript
import {
  render,
  renderWithErrors,
  redirect,
  json,
  notFound,
  forbidden,
} from 'honertia'

// Render a page
return yield* render('Projects/Show', { project })

// Render with validation errors
return yield* renderWithErrors('Projects/Create', {
  name: 'Name is required',
})

// Redirect (303 by default for POST)
return yield* redirect('/projects')
return yield* redirect('/login', 302)

// JSON response
return yield* json({ success: true })
return yield* json({ error: 'Not found' }, 404)

// Error responses
return yield* notFound('Project')
return yield* forbidden('You cannot edit this project')
```

## Error Handling

Honertia provides typed errors:

```typescript
import {
  ValidationError,
  UnauthorizedError,
  NotFoundError,
  ForbiddenError,
  HttpError,
} from 'honertia'

// Validation errors automatically re-render with field errors
const input = yield* validateRequest(schema, {
  errorComponent: 'Projects/Create',
})

// Manual error handling
const project = yield* Effect.tryPromise(() =>
  db.query.projects.findFirst({ where: eq(id, projectId) })
)

if (!project) {
  return yield* notFound('Project', projectId)
}

if (project.userId !== user.user.id) {
  return yield* forbidden('You cannot view this project')
}
```

## Authentication

### Layers

```typescript
import { RequireAuthLayer, RequireGuestLayer } from 'honertia'

// Require authentication - fails with UnauthorizedError if no user
effectRoutes(app)
  .provide(RequireAuthLayer)
  .get('/dashboard', showDashboard)

// Require guest - fails if user IS logged in
effectRoutes(app)
  .provide(RequireGuestLayer)
  .get('/login', showLogin)
```

### Helpers

```typescript
import {
  requireAuth,
  requireGuest,
  isAuthenticated,
  currentUser,
} from 'honertia'

// In a handler
export const showProfile = Effect.gen(function* () {
  const user = yield* requireAuth('/login') // Redirect to /login if not auth'd
  return yield* render('Profile', { user: user.user })
})

// Check without failing
const authed = yield* isAuthenticated // boolean
const user = yield* currentUser       // AuthUser | null
```

### Built-in Auth Routes

```typescript
import { effectAuthRoutes } from 'honertia/auth'
import { loginUser, registerUser, logoutUser, verify2FA, forgotPassword } from './actions/auth'

effectAuthRoutes(app, {
  // Page routes
  loginPath: '/login',           // GET: show login page
  registerPath: '/register',     // GET: show register page
  logoutPath: '/logout',         // POST: logout and redirect
  apiPath: '/api/auth',          // Better-auth API handler
  logoutRedirect: '/login',
  loginRedirect: '/',
  loginComponent: 'Auth/Login',
  registerComponent: 'Auth/Register',

  // Form actions (automatically wrapped with RequireGuestLayer)
  loginAction: loginUser,        // POST /login
  registerAction: registerUser,  // POST /register
  logoutAction: logoutUser,      // POST /logout (overrides default)

  // Extended auth flows (all guest-only POST routes)
  guestActions: {
    '/login/2fa': verify2FA,
    '/forgot-password': forgotPassword,
  },
})
```

All `loginAction`, `registerAction`, and `guestActions` are automatically wrapped with
`RequireGuestLayer`, so authenticated users will be redirected. The `logoutAction` is
not wrapped (logout should work regardless of auth state).

To enable CORS for the auth API handler (`/api/auth/*`), pass a `cors` config.
By default, no CORS headers are added (recommended when your UI and API share the same origin).
Use this when your frontend is on a different origin (local dev, separate domain, mobile app, etc.).

```typescript
effectAuthRoutes(app, {
  apiPath: '/api/auth',
  cors: {
    origin: ['http://localhost:5173', 'http://localhost:3000'],
    credentials: true,
  },
})
```

This sets the appropriate `Access-Control-*` headers and handles `OPTIONS` preflight for the auth API routes.
Always keep the `origin` list tight; avoid `'*'` for auth endpoints, especially with `credentials: true`.

### Better-auth Form Actions

Honertia provides `betterAuthFormAction` to handle the common pattern of form-based
authentication: validate input, call better-auth, map errors to field-level messages,
and redirect on success. This bridges better-auth's JSON responses with Inertia's
form handling conventions.

```typescript
// src/actions/auth/login.ts
import { betterAuthFormAction } from 'honertia/auth'
import { Schema as S } from 'effect'
import { requiredString, email } from 'honertia'
import type { Auth } from './lib/auth' // your better-auth instance type

const LoginSchema = S.Struct({
  email,
  password: requiredString,
})

// Map better-auth error codes to user-friendly field errors
const mapLoginError = (error: { code?: string; message?: string }) => {
  switch (error.code) {
    case 'INVALID_EMAIL_OR_PASSWORD':
      return { email: 'Invalid email or password' }
    case 'USER_NOT_FOUND':
      return { email: 'No account found with this email' }
    case 'INVALID_PASSWORD':
      return { password: 'Incorrect password' }
    default:
      return { email: error.message ?? 'Login failed' }
  }
}

export const loginUser = betterAuthFormAction({
  schema: LoginSchema,
  errorComponent: 'Auth/Login',
  redirectTo: '/',
  errorMapper: mapLoginError,
  // `auth` is the better-auth instance from AuthService
  // `input` is the validated form data
  // `request` is the original Request (needed for session cookies)
  call: (auth: Auth, input, request) =>
    auth.api.signInEmail({
      body: { email: input.email, password: input.password },
      request,
      returnHeaders: true,
    }),
})
```

```typescript
// src/actions/auth/register.ts
import { betterAuthFormAction } from 'honertia/auth'
import { Schema as S } from 'effect'
import { requiredString, email, password } from 'honertia'
import type { Auth } from './lib/auth'

const RegisterSchema = S.Struct({
  name: requiredString,
  email,
  password: password({ min: 8, letters: true, numbers: true }),
})

const mapRegisterError = (error: { code?: string; message?: string }) => {
  switch (error.code) {
    case 'USER_ALREADY_EXISTS':
      return { email: 'An account with this email already exists' }
    case 'PASSWORD_TOO_SHORT':
      return { password: 'Password must be at least 8 characters' }
    default:
      return { email: error.message ?? 'Registration failed' }
  }
}

export const registerUser = betterAuthFormAction({
  schema: RegisterSchema,
  errorComponent: 'Auth/Register',
  redirectTo: '/',
  errorMapper: mapRegisterError,
  call: (auth: Auth, input, request) =>
    auth.api.signUpEmail({
      body: { name: input.name, email: input.email, password: input.password },
      request,
      returnHeaders: true,
    }),
})
```

For logout, use the simpler `betterAuthLogoutAction`:

```typescript
// src/actions/auth/logout.ts
import { betterAuthLogoutAction } from 'honertia/auth'

export const logoutUser = betterAuthLogoutAction({
  redirectTo: '/login',
})
```

**How errors are handled:**

1. **Schema validation fails** ‚Üí Re-renders `errorComponent` with field errors from Effect Schema
2. **better-auth returns an error** ‚Üí Calls your `errorMapper`, then re-renders `errorComponent` with those errors
3. **Success** ‚Üí Sets session cookies from better-auth's response headers, then 303 redirects to `redirectTo`

## React Integration

### Page Component Type

```typescript
import type { HonertiaPage } from 'honertia'

interface ProjectsProps {
  projects: Project[]
}

const ProjectsIndex: HonertiaPage<ProjectsProps> = ({ projects, errors }) => {
  return (
    <div>
      {errors?.name && <span className="error">{errors.name}</span>}
      {projects.map(p => <ProjectCard key={p.id} project={p} />)}
    </div>
  )
}

export default ProjectsIndex
```

### Shared Props

All pages receive shared props set via middleware:

```typescript
// Server: shareAuthMiddleware() adds auth data
// Client: access via props
const Layout: HonertiaPage<Props> = ({ auth, children }) => {
  return (
    <div>
      {auth?.user ? (
        <span>Welcome, {auth.user.name}</span>
      ) : (
        <a href="/login">Login</a>
      )}
      {children}
    </div>
  )
}
```

## TypeScript

### Typed Services via Module Augmentation

By default, `DatabaseService` and `AuthService` are typed as `unknown` since Honertia is database and auth agnostic. You can provide your specific types via module augmentation:

```typescript
// src/types.d.ts (or any .d.ts file in your project)
import type { Database } from '~/db/db'
import type { auth } from '~/lib/auth'

declare module 'honertia/effect' {
  interface HonertiaDatabaseType {
    db: Database // Your Drizzle/Prisma/Kysely type
  }

  interface HonertiaAuthType {
    auth: typeof auth // Your better-auth instance type
  }
}
```

Once augmented, `DatabaseService` and `AuthService` will be properly typed:

```typescript
// Before augmentation: db is `unknown`, requires casting
const db = (yield* DatabaseService) as Database

// After augmentation: db is typed as `Database`
const db = yield* DatabaseService
const projects = yield* Effect.tryPromise(() =>
  db.query.projects.findMany() // ‚úÖ Full type safety
)
```

## Architecture Notes

### Request-Scoped Services

Honertia creates a fresh Effect runtime per request via `effectBridge()`. This is required for Cloudflare Workers where I/O objects cannot be shared between requests.

```typescript
// This happens automatically in effectBridge middleware:
const layer = buildContextLayer(c)      // Build layers from Hono context
const runtime = ManagedRuntime.make(layer) // New runtime per request
// ... handle request ...
await runtime.dispose()                  // Cleanup after request
```

This approach provides full type safety - your handlers declare their service requirements, and the type system ensures they're provided.

### Why Not Global Runtime?

On Cloudflare Workers, database connections and other I/O objects are isolated per request. Using a global runtime with `FiberRef` would lose type safety. The per-request runtime approach ensures:

1. Type-safe dependency injection
2. Proper resource cleanup
3. Full compatibility with Workers' isolation model

If you're using PlanetScale with Hyperdrive, the "connection" you create per request is lightweight - it's just a client pointing at Hyperdrive's persistent connection pool.

## Acknowledgements

- Inertia.js by Jonathan Reinink and its contributors
- Laravel by Taylor Otwell and the Laravel community

üêê

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

MIT
